# preprocess.py
import os, cv2, shutil
from mtcnn import MTCNN
from tqdm import tqdm

detector = MTCNN()

def extract_frames_from_video(video_path, out_folder, step=5):
    os.makedirs(out_folder, exist_ok=True)
    cap = cv2.VideoCapture(video_path)
    i = 0
    saved = 0
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        if i % step == 0:
            cv2.imwrite(os.path.join(out_folder, f"frame_{i:06d}.jpg"), frame)
            saved += 1
        i += 1
    cap.release()
    return saved

def detect_and_align_face(img):
    # MTCNN returns bounding boxes and keypoints
    faces = detector.detect_faces(img)
    if len(faces) == 0:
        return None
    # take largest face
    faces = sorted(faces, key=lambda f: f['box'][2]*f['box'][3], reverse=True)
    f = faces[0]
    x, y, w, h = f['box']
    x, y = max(0, x), max(0, y)
    crop = img[y:y+h, x:x+w]
    # simple resize to 112x112
    aligned = cv2.resize(crop, (112, 112))
    return aligned

def process_directory(src_dir, dst_dir, step=5):

    os.makedirs(dst_dir, exist_ok=True)
    for person in os.listdir(src_dir):
        psrc = os.path.join(src_dir, person)
        pdst = os.path.join(dst_dir, person)
        os.makedirs(pdst, exist_ok=True)
        # iterate files
        for fname in os.listdir(psrc):
            fpath = os.path.join(psrc, fname)
            if fname.lower().endswith(('.mp4', '.mov', '.avi', '.mkv')):
                tmpdir = os.path.join(pdst, "tmp_frames")
                os.makedirs(tmpdir, exist_ok=True)
                extract_frames_from_video(fpath, tmpdir, step=step)
                for frame in os.listdir(tmpdir):
                    frame_path = os.path.join(tmpdir, frame)
                    img = cv2.imread(frame_path)
                    aligned = detect_and_align_face(img)
                    if aligned is not None:
                        cv2.imwrite(os.path.join(pdst, f"{person}_{frame}"), aligned)
                shutil.rmtree(tmpdir)
            elif fname.lower().endswith(('.jpg', '.jpeg', '.png')):
                img = cv2.imread(fpath)
                aligned = detect_and_align_face(img)
                if aligned is not None:
                    base = os.path.splitext(fname)[0]
                    cv2.imwrite(os.path.join(pdst, f"{person}_{base}.jpg"), aligned)
        print(f"Processed {person}")


if __name__ == "__main__":
    SRC_DIR = "data_raw"        # thư mục dữ liệu gốc
    DST_DIR = "data_aligned"    # thư mục lưu kết quả sau xử lý
    process_directory(SRC_DIR, DST_DIR, step=5)
